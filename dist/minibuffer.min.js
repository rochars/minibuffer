function endianness(t,r,a=0,n=t.length){if(n%r)throw Error("Bad buffer length.");for(let e=a;e<n;e+=r)swap(t,r,e)}function swap(t,r,a){r--;for(let n=0;n<r;n++){let e=t[a+n];t[a+n]=t[a+r],t[a+r]=e,r--}}function unpack(t,r=0,a=t.length){let n="";for(let e=r;e<a;){let r=128,a=191,s=!1,i=t[e++];if(i>=0&&i<=127)n+=String.fromCharCode(i);else{let o=0;i>=194&&i<=223?o=1:i>=224&&i<=239?(o=2,224===t[e]&&(r=160),237===t[e]&&(a=159)):i>=240&&i<=244?(o=3,240===t[e]&&(r=144),244===t[e]&&(a=143)):s=!0,i&=(1<<8-o-1)-1;for(let n=0;n<o;n++)(t[e]<r||t[e]>a)&&(s=!0),i=i<<6|63&t[e],e++;n+=s?"ï¿½":i<=65535?String.fromCharCode(i):String.fromCharCode(55296+((i-=65536)>>10&1023),56320+(1023&i))}}return n}function pack(t,r,a=0){for(let n=0,e=t.length;n<e;n++){let e=t.codePointAt(n);if(e<128)r[a]=e,a++;else{let t=0,s=0;for(e<=2047?(t=1,s=192):e<=65535?(t=2,s=224):e<=1114111&&(t=3,s=240,n++),r[a]=(e>>6*t)+s,a++;t>0;)r[a]=128|e>>6*(t-1)&63,a++,t--}}return a}const TYPE_ERR="Unsupported type";function validateIsInt(t){validateIsNumber(t),t==t&&t!==1/0&&t!==-1/0||throwValueErr_("integer")}function validateIsNumber(t){null==t&&throwValueErr_(),t.constructor!=Number&&t.constructor!=Boolean&&throwValueErr_()}function validateFloatType(t){if(!t||16!==t&&32!==t&&64!==t)throw Error(TYPE_ERR+": float, bits: "+t)}function validateIntType(t){if(!t||t<1||t>53)throw Error(TYPE_ERR+": int, bits: "+t)}function throwValueErr_(t="valid number"){throw Error("Argument is not a "+t)}class IEEE754Buffer{constructor(t,r){this.ebits=t,this.fbits=r,this.bias=(1<<t-1)-1,this.numBytes=Math.ceil((t+r)/8),this.biasP2=Math.pow(2,this.bias+1),this.ebitsFbits=t+r,this.fbias=Math.pow(2,-(8*this.numBytes-1-t))}pack(t,r,a){Math.abs(r)>this.biasP2-2*this.ebitsFbits&&(r=r<0?-1/0:1/0);let n=((r=+r)||1/r)<0?1:r<0?1:0,e=Math.min(Math.floor(Math.log(r=Math.abs(r))/Math.LN2),1023),s=this.roundToEven(r/Math.pow(2,e)*Math.pow(2,this.fbits));return r!=r?(s=Math.pow(2,this.fbits-1),e=(1<<this.ebits)-1):0!==r&&(r>=Math.pow(2,1-this.bias)?(s/Math.pow(2,this.fbits)>=2&&(e+=1,s=1),e>this.bias?(e=(1<<this.ebits)-1,s=0):(e+=this.bias,s=this.roundToEven(s)-Math.pow(2,this.fbits))):(s=this.roundToEven(r/Math.pow(2,1-this.bias-this.fbits)),e=0)),this.packFloatBits_(t,a,n,e,s)}unpack(t,r){let a,n=(1<<this.ebits)-1,e="";for(let a=this.numBytes-1;a>=0;a--){let n=t[a+r].toString(2);e+="00000000".substring(n.length)+n}let s="1"==e.charAt(0)?-1:1;e=e.substring(1);let i=parseInt(e.substring(0,this.ebits),2);return e=e.substring(this.ebits),i==n?0!==parseInt(e,2)?NaN:s*(1/0):(0===i?(i+=1,a=parseInt(e,2)):a=parseInt("1"+e,2),s*a*this.fbias*Math.pow(2,i-this.bias))}packFloatBits_(t,r,a,n,e){let s=[];s.push(a);for(let t=this.ebits;t>0;t-=1)s[t]=n%2?1:0,n=Math.floor(n/2);let i=s.length;for(let t=this.fbits;t>0;t-=1)s[i+t]=e%2?1:0,e=Math.floor(e/2);let o=s.join(""),u=this.numBytes+r-1,c=r;for(;u>=r;)t[u]=parseInt(o.substring(0,8),2),o=o.substring(8),u--,c++;return c}roundToEven(t){var r=Math.floor(t),a=t-r;return a<.5?r:a>.5?r+1:r%2?r+1:r}}class UintBuffer{constructor(t){this.bits=t,this.bytes=t<8?1:Math.ceil(t/8),this.max=Math.pow(2,t)-1,this.min=0;let r=8-(1+(t-1|7)-t);this.lastByteMask_=Math.pow(2,r>0?r:8)-1}pack(t,r,a=0){if(r!=r)throw Error("NaN");this.overflow(r),t[a]=255&(r<0?r+Math.pow(2,this.bits):r),a++;let n=this.bytes;for(let e=2;e<n;e++)t[a]=255&Math.floor(r/Math.pow(2,8*(e-1))),a++;return this.bits>8&&(t[a]=Math.floor(r/Math.pow(2,8*(this.bytes-1)))&this.lastByteMask_,a++),a}unpack(t,r=0){let a=this.unpackUnsafe(t,r);return this.overflow(a),a}unpackUnsafe(t,r){let a=0;for(let n=0;n<this.bytes;n++)a+=t[r+n]*Math.pow(256,n);return a}overflow(t){if(t>this.max||t<this.min)throw Error("Overflow")}}class TwosComplementBuffer extends UintBuffer{constructor(t){super(t),this.max=Math.pow(2,this.bits)/2-1,this.min=-this.max-1}pack(t,r,a=0){return super.pack(t,r,a)}unpack(t,r=0){let a=super.unpackUnsafe(t,r);return a=this.sign_(a),this.overflow(a),a}sign_(t){return t>this.max&&(t-=2*this.max+2),t}}class NumberBuffer{constructor(t,r,a){this.parser=null,r?(validateFloatType(t),this.parser=this.getFPParser_(t)):(validateIntType(t),this.parser=a?new TwosComplementBuffer(t):new UintBuffer(t),this.parser.bytes=8===this.parser.bytes?4:this.parser.bytes)}unpack(t,r=0){return this.parser.unpack(t,r)}pack(t,r,a=0){return this.parser.pack(t,r,a)}getFPParser_(t){return 16===t?new IEEE754Buffer(5,11):32===t?new IEEE754Buffer(8,23):new IEEE754Buffer(11,52)}}function unpackString(t,r=0,a=t.length){return unpack(t,r,a)}function packString(t){let r=[];return pack(t,r,0),r}function packStringTo(t,r,a=0){return pack(t,r,a)}function pack$1(t,r){let a=[];return packTo(t,r,a),a}function packTo(t,r,a,n=0){return packArrayTo([t],r,a,n)}function packArray(t,r){let a=[];return packArrayTo(t,r,a),a}function packArrayTo(t,r,a,n=0){let e=new NumberBuffer((r=r||{}).bits,r.fp,r.signed),s=offset_(r.bits),i=r.fp?validateIsNumber:validateIsInt,o=0;try{for(let u=t.length;o<u;o++){i(t[o]);let u=n+s;for(;n<u;)n=e.pack(a,t[o],n);swap_(r.be,a,s,n-s,n)}}catch(t){throw Error(t.message+" at input index "+o)}return n}function unpack$1(t,r,a=0){return unpackArray(t,r,a,a+offset_(r.bits),!0)[0]}function unpackArray(t,r,a=0,n=t.length,e=!1){let s=[];return unpackArrayTo(t,r,s,a,n,e),s}function unpackArrayTo(t,r,a,n=0,e=t.length,s=!1){let i=new NumberBuffer((r=r||{}).bits,r.fp,r.signed),o=offset_(r.bits),u=(e-n)%o;if(s&&(u||t.length<o))throw Error("Bad buffer length");e-=u;let c=0;try{swap_(r.be,t,o,n,e);for(let r=n;r<e;r+=o,c++)a[c]=i.unpack(t,r);swap_(r.be,t,o,n,e)}catch(t){throw Error(t.message+" at output index "+c)}}function swap_(t,r,a,n,e){t&&endianness(r,a,n,e)}function offset_(t){return t<8?1:Math.ceil(t/8)}function unpackString$1(t,r=0,a=t.length){return unpackString(t,r,a)}function packString$1(t){return packString(t)}function packStringTo$1(t,r,a=0){return packStringTo(t,r,a)}function pack$2(t,r){return pack$1(t,r)}function packTo$1(t,r,a,n=0){return packTo(t,r,a,n)}function packArray$1(t,r){return packArray(t,r)}function packArrayTo$1(t,r,a,n=0){return packArrayTo(t,r,a,n)}function unpack$2(t,r,a=0){return unpack$1(t,r,a)}function unpackArray$1(t,r,a=0,n=t.length,e=!1){return unpackArray(t,r,a,n,e)}function unpackArrayTo$1(t,r,a,n=0,e=t.length,s=!1){unpackArrayTo(t,r,a,n,e,s)}export{unpackString$1 as unpackString,packString$1 as packString,packStringTo$1 as packStringTo,pack$2 as pack,packTo$1 as packTo,packArray$1 as packArray,packArrayTo$1 as packArrayTo,unpack$2 as unpack,unpackArray$1 as unpackArray,unpackArrayTo$1 as unpackArrayTo};
