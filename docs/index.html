<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Home - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-minibuffer.html">minibuffer</a><ul class='methods'><li data-type='method'><a href="module-minibuffer.html#.pack">pack</a></li><li data-type='method'><a href="module-minibuffer.html#.packArray">packArray</a></li><li data-type='method'><a href="module-minibuffer.html#.packArrayTo">packArrayTo</a></li><li data-type='method'><a href="module-minibuffer.html#.packString">packString</a></li><li data-type='method'><a href="module-minibuffer.html#.packStringTo">packStringTo</a></li><li data-type='method'><a href="module-minibuffer.html#.packTo">packTo</a></li><li data-type='method'><a href="module-minibuffer.html#.unpack">unpack</a></li><li data-type='method'><a href="module-minibuffer.html#.unpackArray">unpackArray</a></li><li data-type='method'><a href="module-minibuffer.html#.unpackArrayTo">unpackArrayTo</a></li><li data-type='method'><a href="module-minibuffer.html#.unpackString">unpackString</a></li></ul></li></ul>
</nav>

<div id="main">
    

    



    









    


    <section class="readme">
        <article><h1>minibuffer</h1><p>Pack and unpack binary data.<br>Copyright (c) 2018 Rafael da Silva Rocha.<br>https://github.com/rochars/minibuffer</p>
<p><a href="https://www.npmjs.com/package/minibuffer"><img src="https://img.shields.io/npm/v/minibuffer.svg?style=for-the-badge" alt="NPM version"></a> <a href="https://rochars.github.io/minibuffer/docs/index.html"><img src="https://img.shields.io/badge/docs-online-blue.svg?style=for-the-badge" alt="Docs"></a> <a href="https://rochars.github.io/minibuffer/test/dist/browser.html"><img src="https://img.shields.io/badge/tests-online-blue.svg?style=for-the-badge" alt="Tests"></a><br><a href="https://codecov.io/gh/rochars/minibuffer"><img src="https://img.shields.io/codecov/c/github/rochars/minibuffer.svg?style=flat-square" alt="Codecov"></a> <a href="https://travis-ci.org/rochars/minibuffer"><img src="https://img.shields.io/travis/rochars/minibuffer.svg?style=flat-square" alt="Unix Build"></a> <a href="https://ci.appveyor.com/project/rochars/minibuffer"><img src="https://img.shields.io/appveyor/ci/rochars/minibuffer.svg?style=flat-square&amp;logo=appveyor" alt="Windows Build"></a> <a href="https://scrutinizer-ci.com/g/rochars/minibuffer/"><img src="https://img.shields.io/scrutinizer/g/rochars/minibuffer.svg?style=flat-square&amp;logo=scrutinizer" alt="Scrutinizer"></a></p>
<p><strong>minibuffer</strong> is a ES module to pack and unpack numbers and strings to and from byte buffers.</p>
<ul>
<li><strong>MIT licensed</strong></li>
<li><strong>Type safe</strong></li>
<li><strong>Use it out of the box in Node.js</strong></li>
<li><strong>Use it out of the box with <a href="https://www.typescriptlang.org/">TypeScript</a></strong></li>
<li><strong>Tested in little-endian and big-endian machines!</strong></li>
<li><strong>Less than 7kb minified!</strong></li>
</ul>
<h2>Pack/unpack:</h2><ul>
<li>Integers, unsigned and signed (two's complement)</li>
<li>16-bit half-precision floating-point numbers</li>
<li>32-bit single-precision floating-point numbers</li>
<li>64-bit double-precision floating-point numbers</li>
<li>Little-endian and big-endian words</li>
<li>UTF-8 strings (1 to 4 bytes per character, invalid characters are replaced)</li>
</ul>
<h2>Install</h2><pre class="prettyprint source"><code>npm install minibuffer</code></pre><h2>Browser</h2><p>Use <strong>minibuffer.umd.js</strong> in the <em>/dist</em> folder of this package:</p>
<pre class="prettyprint source lang-html"><code>&lt;script src=&quot;./dist/minibuffer.umd.js&quot;>&lt;/script>
&lt;script>
  // Pack a 32-bit floating-point number
  var packed = minibuffer.pack(2.1474836, {bits: 32, fp: true});
&lt;/script></code></pre><p>Or load it from the <a href="https://cdn.jsdelivr.net/npm/minibuffer">jsDelivr</a> CDN:</p>
<pre class="prettyprint source lang-html"><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/minibuffer&quot;>&lt;/script></code></pre><p>Or load it from <a href="https://unpkg.com/minibuffer">unpkg</a>:</p>
<pre class="prettyprint source lang-html"><code>&lt;script src=&quot;https://unpkg.com/minibuffer&quot;>&lt;/script></code></pre><h3>Browser compatibility</h3><p>Should work in all modern browsers that support ES5/ES6+.</p>
<p>Cross-browser tests powered by<br><a href="https://www.browserstack.com"><img src="https://rochars.github.io/minibuffer/docs/Browserstack-logo@2x.png" width="150px"/></a></p>
<h2>Node</h2><pre class="prettyprint source lang-javascript"><code>import * as minibuffer from 'minibuffer';

// Pack a signed 16-bit integer to a existing byte buffer
// Start writing on index '4' of the buffer
minibuffer.packTo(1077, {bits: 16, signed: true}, buffer, 4);

// Pack a usigned 8-bit unsigned integer, returns a
// array with the number represented as bytes
let packed = minibuffer.pack(128, {bits: 8});</code></pre><p>Or <strong>import</strong> just what you need:</p>
<pre class="prettyprint source lang-javascript"><code>import {pack} from 'minibuffer';

// Pack a 8-bit unsigned integer
let packed = pack(128, {bits: 8});</code></pre><p>Or <strong>require</strong>:</p>
<pre class="prettyprint source lang-javascript"><code>const minibuffer = require('minibuffer');

// Pack a 32-bit floating-point number
let packed = minibuffer.pack(2.1474836, {bits: 32, fp: true});</code></pre><h2>About</h2><h2>pack and packTo</h2><p><strong>pack(num, theType)</strong> will return a <em>Array</em> with the bytes of the passed value.</p>
<pre class="prettyprint source lang-javascript"><code>let packed = pack(123, {bits: 16});</code></pre><p><strong>packTo(num, theType, buffer, index)</strong> will write the bytes of the number to the provided buffer (<em>Uint8Array</em> or <em>Array</em>), start writing on <em>index</em>.</p>
<pre class="prettyprint source lang-javascript"><code>let buffer = new Uint8Array(4);
packTo(402, {bits: 16}, buffer, 2);</code></pre><p><em>index</em> can be ommited and will default to <strong>zero</strong>:</p>
<pre class="prettyprint source lang-javascript"><code>let buffer = new Uint8Array(4);
packTo(402, {bits: 16}, buffer);</code></pre><h3>Packing <em>null</em>, <em>false</em>, <em>true</em> and <em>undefined</em></h3><ul>
<li>Packing <em>undefined</em> or <em>null</em> values throw <em>'Argument is not a valid number'</em> error</li>
<li><em>true</em> is packed as 1</li>
<li><em>false</em> is packed as 0</li>
</ul>
<h3>Unpacking and input buffer length</h3><h4>unpack(buffer, theType, index=)</h4><p>When unpacking a single value, a <em>'Bad buffer length'</em> error is raised if the number of bytes is not sufficient (Ex: unpack a 32-bit number, but provide a input buffer with length smaller than 4) or if there are not enough bytes after the <em>index</em>.</p>
<pre class="prettyprint source lang-javascript"><code>minibuffer.unpack([0xff], {bits: 16}, 0); // throws a 'Bad buffer length' error
minibuffer.unpack([0xff, 0xff, 0xff], {bits: 16}, 2); // throws a 'Bad buffer length' error
minibuffer.unpack([0xff, 0xff, 0xff], {bits: 16}, 1); // ok</code></pre><h4>unpackArray(buffer, theType, start=, end=, safe=)</h4><p>When unpacking a array of values, <strong>extra bytes in the end of the buffer are ignored</strong> and <strong>insufficient bytes will return a empty array</strong> by default:</p>
<pre class="prettyprint source lang-javascript"><code>minibuffer.unpackArray([0xff], {bits: 16}, 0, 1); // return a empty array
minibuffer.unpackArray([0xff, 0xff, 0xff], {bits: 16}, 0, 2); // return a array with one 16-bit unsigned int</code></pre><p>You can unpack arrays in <strong>safe mode</strong> with the optional <em>safe</em> param set to <em>true</em>. <strong>In safe mode insufficient bytes in the input array or extra bytes in the end of the input array will cause a 'Bad buffer length' error</strong>:</p>
<pre class="prettyprint source lang-javascript"><code>minibuffer.unpackArray([0xff], {bits: 16}, 0, 1, true); // throws a 'Bad buffer length' error
minibuffer.unpackArray([0xff, 0xff, 0xff], {bits: 16}, 0, 3, true); // throws a 'Bad buffer length' error</code></pre><h3>Floating-point numbers</h3><ul>
<li>Floating-point numbers are <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a> standard.</li>
<li><strong>Overflows</strong> are rounded towards <strong>Infinity</strong> and <strong>-Infinity</strong>.</li>
<li><strong>NaN</strong> is packed as quiet NaN. Both <strong>quiet NaN</strong> and <strong>signaling NaN</strong> can be unpacked.</li>
<li>Support packing and unpacking <strong>negative zeros</strong>.</li>
<li>Support packing and unpacking <strong>Infinity</strong> and <strong>negative Infinity</strong></li>
</ul>
<h4>Minifloats</h4><p>Currently only 16-bit half-precision.</p>
<h3>Integers</h3><ul>
<li>Overflow on integers will throw a <em>&quot;Overflow&quot;</em> error.</li>
<li>packing NaN will throw a 'Argument is not a integer' error.</li>
<li>packing Infinity or -Infinity will throw a 'Argument is not a integer' error.</li>
</ul>
<h4>Signed integers</h4><p>Signed integers are <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's complement</a>.</p>
<h3>Strings</h3><p><strong>UTF-8 strings</strong> with 1 to 4 bytes per character can be packed and unpacked. <strong>BOM</strong> is kept untouched if present. Invalid characters are replaced with <em>Unicode Character 'REPLACEMENT CHARACTER' (U+FFFD)</em>.</p>
<h4>Reading strings from buffers</h4><p>Use <strong>unpackString(buffer, index, end)</strong>. The paramters <strong>index</strong> and <strong>end</strong> determine a slice of the buffer to read. <strong>End is non-inclusive</strong>. So to read the first 4 bytes of a buffer:</p>
<pre class="prettyprint source lang-javascript"><code>let str = unpackString(buffer, 0, 4);
// read from buffer[0], buffer[1], buffer[2], buffer[3]</code></pre><p>If <strong>index</strong> and <strong>end</strong> are ommited unpackString(buffer) will read the entire buffer:</p>
<pre class="prettyprint source lang-javascript"><code>let str = unpackString(buffer);</code></pre><h4>Writing strings to buffers</h4><p><strong>packStringTo(str, buffer, index=0)</strong> will write the string to the provided buffer (<em>Uint8Array</em> or <em>Array</em>), starting on the <strong>index</strong>. Index defaults to zero if ommited (start from the beginning of the buffer).</p>
<pre class="prettyprint source lang-javascript"><code>let buffer = [];
packStringTo(str, buffer);</code></pre><h5>Packing strings to Uint8Array buffers</h5><p>If you need to calculate the buffer length before writing you may use the <strong>utf8-buffer-size</strong> module:</p>
<pre class="prettyprint source lang-javascript"><code>import utf8BufferSize from 'utf8-buffer-size';
let buffer = new Uint8Array(utf8BufferSize(str));
packStringTo(str, buffer);</code></pre><h3>Types</h3><p>Types are user-defined objects like this:</p>
<pre class="prettyprint source lang-javascript"><code>const binary32 = {
  bits: 32, // required
  signed: true, // optional, defaults to false
  fp: true, // optional, defaults to false, true for floating-point numbers
  be: false // optional, defaults to false, true for big-endian
}</code></pre><h3>Tests on big-endian systems</h3><p>Use <a href="https://www.qemu.org/">QEMU</a> with this PowerPC/Debian image:<br>https://people.debian.org/~aurel32/qemu/powerpc/</p>
<h2>API</h2><pre class="prettyprint source lang-javascript"><code>// Strings
/**
 * Read a string of UTF-8 characters from a byte buffer.
 * @param {!Uint8Array|!Array&lt;number>} buffer A byte buffer.
 * @param {number=} index The buffer index to start reading.
 * @param {number=} end The buffer index to stop reading, non inclusive.
 *   Assumes buffer length if undefined.
 * @return {string}
 */
function unpackString(buffer, index=0, len=buffer.length) {}

/**
 * Write a string of UTF-8 characters as a byte buffer.
 * @param {string} str The string to pack.
 * @return {!Array&lt;number>} The UTF-8 string bytes.
 */ 
function packString(str) {}

/**
 * Write a string of UTF-8 characters to a byte buffer.
 * @param {string} str The string to pack.
 * @param {!Uint8Array|!Array&lt;number>} buffer The output buffer.
 * @param {number=} index The buffer index to start writing.
 *   Assumes zero if undefined.
 * @return {number} The next index to write in the buffer.
 */
function packStringTo(str, buffer, index=0) {}

// Numbers
/**
 * Pack a number as a byte buffer.
 * @param {number} value The number.
 * @param {!Object} theType The type definition.
 * @return {!Array&lt;number>} The packed value.
 * @throws {Error} If the type definition is not valid.
 * @throws {Error} If the value is not valid.
 */
function pack(value, theType) {}

/**
 * Pack a number to a byte buffer.
 * @param {number} value The value.
 * @param {!Object} theType The type definition.
 * @param {!Uint8Array|!Array&lt;number>} buffer The output buffer.
 * @param {number=} index The buffer index to write. Assumes 0 if undefined.
 * @return {number} The next index to write.
 * @throws {Error} If the type definition is not valid.
 * @throws {Error} If the value is not valid.
 */
function packTo(value, theType, buffer, index=0) {}

/**
 * Pack an array of numbers as a byte buffer.
 * @param {!Array&lt;number>|!TypedArray} values The values.
 * @param {!Object} theType The type definition.
 * @return {!Array&lt;number>} The packed values.
 * @throws {Error} If the type definition is not valid.
 * @throws {Error} If any of the values are not valid.
 */
function packArray(values, theType) {}

/**
 * Pack a array of numbers to a byte buffer.
 * @param {!Array&lt;number>|!TypedArray} values The value.
 * @param {!Object} theType The type definition.
 * @param {!Uint8Array|!Array&lt;number>} buffer The output buffer.
 * @param {number=} index The buffer index to start writing.
 *   Assumes zero if undefined.
 * @return {number} The next index to write.
 * @throws {Error} If the type definition is not valid.
 * @throws {Error} If the value is not valid.
 */
function packArrayTo(values, theType, buffer, index=0) {}

/**
 * Unpack a number from a byte buffer.
 * @param {!Uint8Array|!Array&lt;number>} buffer The byte buffer.
 * @param {!Object} theType The type definition.
 * @param {number=} index The buffer index to read. Assumes zero if undefined.
 * @return {number}
 * @throws {Error} If the type definition is not valid
 * @throws {Error} On bad buffer length.
 */
function unpack(buffer, theType, index=0) {}

/**
 * Unpack an array of numbers from a byte buffer.
 * @param {!Uint8Array|!Array&lt;number>} buffer The byte buffer.
 * @param {!Object} theType The type definition.
 * @param {number=} start The buffer index to start reading.
 *   Assumes zero if undefined.
 * @param {number=} end The buffer index to stop reading.
 *   Assumes the buffer length if undefined.
 * @param {boolean=} safe If set to false, extra bytes in the end of
 *   the array are ignored and input buffers with insufficient bytes will
 *   output a empty array. If safe is set to true the function
 *   will throw a 'Bad buffer length' error. Defaults to false.
 * @return {!Array&lt;number>}
 * @throws {Error} If the type definition is not valid
 */
function unpackArray(
  buffer, theType, start=0, end=buffer.length, safe=false) {}

/**
 * Unpack a array of numbers to a typed array.
 * @param {!Uint8Array|!Array&lt;number>} buffer The byte buffer.
 * @param {!Object} theType The type definition.
 * @param {!TypedArray|!Array&lt;number>} output The output array.
 * @param {number=} index The buffer index to start reading.
 *   Assumes zero if undefined.
 * @param {number=} end The buffer index to stop reading.
 *   Assumes the buffer length if undefined.
 * @param {boolean=} safe If set to false, extra bytes in the end of
 *   the array are ignored and input buffers with insufficient bytes will
 *   write nothing to the output array. If safe is set to true the function
 *   will throw a 'Bad buffer length' error. Defaults to false.
 * @throws {Error} If the type definition is not valid
 */
function unpackArrayTo(
  buffer, theType, output, index=0, end=buffer.length, safe=false) {}</code></pre><h2>Contributing</h2><p><strong>minibuffer</strong> welcomes all contributions from anyone willing to work in good faith with other contributors and the community. No contribution is too small and all contributions are valued.</p>
<p>See <a href="https://github.com/rochars/minibuffer/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a> for details.</p>
<h3>Style guide</h3><p><strong>minibuffer</strong> code should follow the Google JavaScript Style Guide:<br>https://google.github.io/styleguide/jsguide.html</p>
<h3>Code of conduct</h3><p>This project is bound by a code of conduct: The <a href="https://github.com/rochars/minibuffer/blob/master/CODE_OF_CONDUCT.md">Contributor Covenant, version 1.4</a>, also available at https://<a href="http://www.contributor-covenant.org/version/1/4/code-of-conduct.html">www.contributor-covenant.org/version/1/4/code-of-conduct.html</a></p>
<h2>Reporting issues</h2><p>Use the <a href="https://github.com/rochars/minibuffer/issues">GitHub issue tracker</a>.</p>
<h3>Reporting vulnerabilities</h3><p>Report vulnerabilities to this e-mail: <a href="mailto:rocha.rafaelsilva@gmail.com">rocha.rafaelsilva@gmail.com</a>.</p>
<h2>LICENSE</h2><p>Copyright (c) 2018 Rafael da Silva Rocha.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
&quot;Software&quot;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:</p>
<p>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p></article>
    </section>









<section>

<header>
    
        <h2>
        index.js
        </h2>
        
    
</header>

<article>
    <div class="container-overview">
    
        

<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="index.js.html">index.js</a>, <a href="index.js.html#line25">line 25</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li><a href="https://github.com/rochars/minibuffer">https://github.com/rochars/minibuffer</a></li>
        </ul>
    </dd>
    

    
</dl>




        
            <div class="description">Functions to read and write numbers and strings as bytes.</div>
        

        
    
    </div>

    

    

    

     

    

    

    

    

    
</article>

</section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Aug 06 2018 03:11:46 GMT-0300 (Hora oficial do Brasil) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>